import firebase_admin
from firebase_admin import credentials, firestore, storage
import streamlit as st
from datetime import datetime
import json
import os
import secrets
import string
import base64
from PIL import Image
import io

def initialize_firebase():
    """Inicjalizuje po≈ÇƒÖczenie z Firebase Firestore bez pliku na dysku."""
    if firebase_admin._apps:
        return firestore.client()

    try:
        # Sprawd≈∫ najpierw czy mamy secrets (bez logowania b≈Çƒôd√≥w)
        has_secrets = False
        try:
            has_secrets = "firebase_admin" in st.secrets
        except:
            pass  # Ignore secrets errors
        
        # Metoda 1: Streamlit secrets 
        if has_secrets:
            st.info("üîß Inicjalizacja Firebase ze Streamlit secrets")
            firebase_creds = dict(st.secrets["firebase_admin"])
            cred = credentials.Certificate(firebase_creds)
            firebase_admin.initialize_app(cred)
            return firestore.client()

        # Metoda 2: Plik JSON
        else:
            credentials_file = "marbabud-firebase-adminsdk-fbsvc-b4355b7a63.json"
            
            if os.path.exists(credentials_file):
                st.info(f"üîß Inicjalizacja Firebase z pliku: {credentials_file}")
                cred = credentials.Certificate(credentials_file)
                firebase_admin.initialize_app(cred)
                db = firestore.client()
                
                # Test po≈ÇƒÖczenia
                try:
                    # Sprawd≈∫ czy mo≈ºna siƒô po≈ÇƒÖczyƒá
                    collections = list(db.collections())
                    st.success("‚úÖ Po≈ÇƒÖczenie z Firebase Firestore nawiƒÖzane")
                    return db
                except Exception as test_error:
                    st.error(f"‚ùå Problemy z po≈ÇƒÖczeniem Firestore: {test_error}")
                    return None
            else:
                st.error(f"‚ùå Nie znaleziono pliku credentials: {credentials_file}")
                st.error("Upewnij siƒô, ≈ºe plik istnieje w katalogu projektu")
                return None

    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd inicjalizacji Firebase: {e}")
        
        # Dodatkowe informacje diagnostyczne
        credentials_file = "marbabud-firebase-adminsdk-fbsvc-b4355b7a63.json"
        if os.path.exists(credentials_file):
            st.error("üìÑ Plik credentials istnieje, ale wystƒÖpi≈Ç b≈ÇƒÖd podczas inicjalizacji")
        else:
            st.error("üìÑ Plik credentials nie istnieje")
        
        return None

@st.cache_resource
def setup_database():
    """Inicjalizuje bazƒô danych z pe≈ÇnƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w"""
    try:
        db = initialize_firebase()
        if db is None:
            st.error("‚ùå Nie uda≈Ço siƒô zainicjalizowaƒá bazy danych Firebase!")
            st.error("üîß Sprawd≈∫ konfiguracjƒô Firebase")
            return None
        
        # Test czy baza faktycznie dzia≈Ça
        try:
            # Sprawd≈∫ czy mo≈ºemy siƒô po≈ÇƒÖczyƒá
            collections = list(db.collections())
            return db
        except Exception as test_error:
            st.error(f"‚ùå Problemy z po≈ÇƒÖczeniem z bazƒÖ: {test_error}")
            return None
            
    except Exception as e:
        st.error(f"‚ùå Krytyczny b≈ÇƒÖd inicjalizacji: {e}")
        return None

def create_tables_if_not_exist(db):
    """
    Tworzy kolekcje w Firestore je≈õli nie istniejƒÖ
    Definiuje strukturƒô danych na podstawie formularzy
    """
    
    # Struktura tabeli dla DRZWI WEJ≈öCIOWYCH
    drzwi_wejsciowe_schema = {
        "id": "", 
        "data_utworzenia": datetime.now(),
        "numer_strony": "",
        "nazwisko": "",
        "telefon": "",
        "pomieszczenie": "",
        "szerokosc_otworu": "",
        "wysokosc_otworu": "",
        "mierzona_od": "",  # szkolenia, poziomu, pod≈Çogi, inne
        "skrot": "",
        "grubosc_muru": "",  # cm
        "stan_sciany": "",   # spos√≥b wyko≈Ñczenia: tapeta, p≈Çyta g-k, itp.
        "oscieznica": "",
        "okapnik": "",
        "prog": "",
        "wizjer": "",
        "elektrozaczep": "",
        "strona_otwierania": {
            "na_zewnatrz": False,
            "do_wewnatrz": False,
            "lewe": False,
            "prawe": False
        },
        # Dane produktu (pola 1-9)
        "producent": "",           # 1. Producent
        "grubosc": "",            # 2. Grubo≈õƒá
        "wzor": "",               # 3. Wz√≥r
        "rodzaj_okleiny": "",     # 4. Rodzaj okleiny
        "ramka": "",              # 5. Ramka (czarna, inox, laminowana)
        "wkladki": "",            # 6. Wk≈Çadki
        "szyba": "",              # 7. Szyba
        "klamka": "",             # 8. Klamka
        "dostawa": "",            # 9. Dostawa (je≈õli jest)
        
        # Podpisy i uwagi
        "podpis_sprzedawcy": "",
        "podpis_klienta": "",
        "uwagi_dla_klienta": "",
        "podpis_klienta_2": "",   # drugi podpis klienta
        "podpis_montera": "",
        
        # Dodatkowe pola systemowe
        "monter_id": "",
        "data_pomiary": None,
        "kod_dostepu": "",
        "sprzedawca_id": "",
        "status": "oczekuje_na_uzupelnienie",
        "uwagi_montera": ""
    }

    # Struktura tabeli dla DRZWI
    drzwi_schema = {
        "id": "", 
        "data_utworzenia": datetime.now(),
        "pomieszczenie": "",
        "imie_nazwisko": "",
        "telefon": "",
        "szerokosc_otworu": "",
        "wysokosc_otworu": "",
        "mierzona_od": "",
        "typ_drzwi": "",
        "norma": "",
        "grubosc_muru": "",
        "stan_sciany": "",
        "oscieznica": "",
        "kolor_osc": "",
        "opaska": "",
        "kat_zaciecia": "",
        "prog": "",
        "wizjer": "",
        "strona_otwierania": {
            "lewe_przyl": False,
            "prawe_przyl": False,
            "lewe_odwr": False,
            "prawe_odwr": False
        },
        "producent": "",
        "seria": "",
        "typ": "",
        "rodzaj_okleiny": "",
        "ilosc_szyb": "",
        "zamek": "",
        "szyba": "",
        "wentylacja": "",
        "klamka": "",
        "opcje_dodatkowe": "",
        "podpis_sprzedawcy": "",
        "podpis_montera": "",
        "podpis_klienta": "",
        "uwagi_klienta": "",
        "podpis_klienta_2": "",
        "status": "aktywny",  # aktywny, zako≈Ñczony, anulowany
        "etap_formularza": "pomiary",  # pomiary, kompletny
        "wypelnil_monter": False,
        "data_pomiary": None,
        "monter_id": "",
        "wypelnil_sprzedawca": False, 
        "data_sprzedaz": None,
        "sprzedawca_id": "",
        "kod_dostepu": "",  # Unikalny kod do udostƒôpnienia
        "link_udostepniony": False
    }
    
    # Struktura tabeli dla POD≈Å√ìG
    podlogi_schema = {
        "id": "",  # Automatyczne ID dokumentu
        "data_utworzenia": datetime.now(),
        "pomieszczenie": "",
        "telefon": "",
        "system_montazu": "",
        "rodzaj_podlogi": "",
        "seria": "",
        "kolor": "",
        "folia": "",
        "podklad": "",
        "listwa_przypodlogowa": "",
        "mdf_mozliwy": "",
        "nw": 0,
        "nz": 0,
        "l": 0,
        "zl": 0,
        "zp": 0,
        "listwy_jaka": "",
        "listwy_ile": "",
        "listwy_gdzie": "",
        "podpis_sprzedawcy": "",
        "podpis_klienta": "",
        "podpis_klienta_2": "",
        "podpis_montera": "",
        "uwagi": "",
        "status": "aktywny",  # aktywny, zako≈Ñczony, anulowany
        "etap_formularza": "pomiary",  # pomiary, kompletny
        "wypelnil_monter": False,
        "data_pomiary": None,
        "monter_id": "",
        "wypelnil_sprzedawca": False, 
        "data_sprzedaz": None,
        "sprzedawca_id": "",
        "kod_dostepu": "",  # Unikalny kod do udostƒôpnienia
        "link_udostepniony": False
    }
    
    try:
        # Sprawd≈∫ czy kolekcja 'drzwi' istnieje
        drzwi_ref = db.collection('drzwi')
        drzwi_docs = drzwi_ref.limit(1).get()
        
        if len(drzwi_docs) == 0:
            # Utw√≥rz przyk≈Çadowy dokument w kolekcji drzwi
            sample_drzwi = drzwi_schema.copy()
            sample_drzwi["pomieszczenie"] = "Przyk≈Çad - Salon"
            sample_drzwi["uwagi_klienta"] = "Kolekcja utworzona automatycznie"
            drzwi_ref.add(sample_drzwi)
            print("‚úÖ Kolekcja 'drzwi' zosta≈Ça utworzona")
        
        # Sprawd≈∫ czy kolekcja 'podlogi' istnieje
        podlogi_ref = db.collection('podlogi')
        podlogi_docs = podlogi_ref.limit(1).get()
        
        if len(podlogi_docs) == 0:
            # Utw√≥rz przyk≈Çadowy dokument w kolekcji podlogi
            sample_podlogi = podlogi_schema.copy()
            sample_podlogi["pomieszczenie"] = "Przyk≈Çad - Pok√≥j"
            sample_podlogi["uwagi"] = "Kolekcja utworzona automatycznie"
            podlogi_ref.add(sample_podlogi)
            print("‚úÖ Kolekcja 'podlogi' zosta≈Ça utworzona")
            
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas tworzenia kolekcji: {e}")

def save_drzwi_data(db, dane_formularza):
    """
    Zapisuje dane formularza drzwi do bazy danych
    """
    try:
        # Dodaj metadane
        dane_formularza["data_utworzenia"] = datetime.now()
        dane_formularza["status"] = "aktywny"
        
        # Zapisz do kolekcji 'drzwi'
        doc_ref = db.collection('drzwi').add(dane_formularza)
        
        # doc_ref to tuple (timestamp, DocumentReference)
        document_id = doc_ref[1].id
        print(f"‚úÖ Zapisano dane drzwi z ID: {document_id}")
        return document_id
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania danych drzwi: {e}")
        return None

def save_podlogi_data(db, dane_formularza):
    """
    Zapisuje dane formularza pod≈Ç√≥g do bazy danych
    """
    try:
        # Dodaj metadane
        dane_formularza["data_utworzenia"] = datetime.now()
        dane_formularza["status"] = "aktywny"
        
        # Zapisz do kolekcji 'podlogi'
        doc_ref = db.collection('podlogi').add(dane_formularza)
        
        # doc_ref to tuple (timestamp, DocumentReference)
        document_id = doc_ref[1].id
        print(f"‚úÖ Zapisano dane pod≈Ç√≥g z ID: {document_id}")
        return document_id
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania danych pod≈Ç√≥g: {e}")
        return None

def get_all_drzwi(db):
    """
    Pobiera wszystkie rekordy drzwi z bazy danych
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return []
        
    try:
        docs = db.collection('drzwi').order_by('data_utworzenia', direction=firestore.Query.DESCENDING).get()
        drzwi_list = []
        for doc in docs:
            data = doc.to_dict()
            data['id'] = doc.id
            drzwi_list.append(data)
        return drzwi_list
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas pobierania danych drzwi: {e}")
        return []

def get_all_podlogi(db):
    """
    Pobiera wszystkie rekordy pod≈Ç√≥g z bazy danych
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return []
        
    try:
        docs = db.collection('podlogi').order_by('data_utworzenia', direction=firestore.Query.DESCENDING).get()
        podlogi_list = []
        for doc in docs:
            data = doc.to_dict()
            data['id'] = doc.id
            podlogi_list.append(data)
        return podlogi_list
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas pobierania danych pod≈Ç√≥g: {e}")
        return []

def get_all_drzwi_wejsciowe(db):
    """
    Pobiera wszystkie rekordy drzwi wej≈õciowych z bazy danych
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return []
        
    try:
        docs = db.collection('drzwi_wejsciowe').order_by('data_utworzenia', direction=firestore.Query.DESCENDING).get()
        drzwi_wejsciowe_list = []
        for doc in docs:
            data = doc.to_dict()
            data['id'] = doc.id
            drzwi_wejsciowe_list.append(data)
        return drzwi_wejsciowe_list
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas pobierania danych drzwi wej≈õciowych: {e}")
        return []

def update_record_status(db, collection_name, doc_id, new_status):
    """
    Aktualizuje status rekordu (aktywny, zako≈Ñczony, anulowany)
    """
    try:
        db.collection(collection_name).document(doc_id).update({
            'status': new_status,
            'data_modyfikacji': datetime.now()
        })
        return True
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas aktualizacji statusu: {e}")
        return False

def delete_record(db, collection_name, doc_id):
    """
    Usuwa rekord z bazy danych
    """
    try:
        db.collection(collection_name).document(doc_id).delete()
        return True
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas usuwania rekordu: {e}")
        return False



def generate_access_code():
    """Generuje unikalny kod dostƒôpu dla formularza"""
    return ''.join(secrets.choice(string.ascii_uppercase + string.digits) for _ in range(8))

def save_pomiary_data(db, collection_name, dane_formularza, monter_id):
    """
    Zapisuje czƒô≈õƒá formularza wype≈ÇnionƒÖ przez montera (pomiary)
    """
    try:
        # Dodaj metadane dla etapu pomiar√≥w
        dane_formularza["data_utworzenia"] = datetime.now()
        dane_formularza["etap_formularza"] = "pomiary"
        dane_formularza["wypelnil_monter"] = True
        dane_formularza["data_pomiary"] = datetime.now()
        dane_formularza["monter_id"] = monter_id
        dane_formularza["kod_dostepu"] = generate_access_code()
        dane_formularza["status"] = "pomiary_wykonane"
        
        # Zapisz do odpowiedniej kolekcji
        doc_ref = db.collection(collection_name).add(dane_formularza)
        document_id = doc_ref[1].id
        
        print(f"‚úÖ Zapisano pomiary {collection_name} z ID: {document_id}")
        return document_id, dane_formularza["kod_dostepu"]
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas zapisywania pomiar√≥w {collection_name}: {e}")
        return None, None

def complete_form_by_seller(db, collection_name, doc_id, dane_sprzedawcy, sprzedawca_id):
    """
    Uzupe≈Çnia formularz danymi od sprzedawcy
    """
    try:
        # Aktualizuj dokument o dane sprzedawcy
        update_data = dane_sprzedawcy.copy()
        update_data.update({
            "wypelnil_sprzedawca": True,
            "data_sprzedaz": datetime.now(),
            "sprzedawca_id": sprzedawca_id,
            "etap_formularza": "kompletny",
            "status": "aktywny"
        })
        
        db.collection(collection_name).document(doc_id).update(update_data)
        
        print(f"‚úÖ Formularz {collection_name} zosta≈Ç uko≈Ñczony przez sprzedawcƒô")
        return True
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd podczas uzupe≈Çniania formularza: {e}")
        return False

def get_form_by_access_code(db, collection_name, kod_dostepu):
    """
    Pobiera formularz na podstawie kodu dostƒôpu
    """
    try:
        docs = db.collection(collection_name).where(filter=firestore.FieldFilter('kod_dostepu', '==', kod_dostepu)).limit(1).get()
        
        if docs:
            doc = docs[0]
            data = doc.to_dict()
            data['id'] = doc.id
            return data
        else:
            return None
            
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas wyszukiwania formularza: {e}")
        return None

def get_forms_for_completion(db, collection_name):
    """
    Pobiera formularze gotowe do uzupe≈Çnienia przez sprzedawcƒô
    U≈ºywa prostszego zapytania aby uniknƒÖƒá problem√≥w z indeksami
    """
    try:
        # Najpierw pobierz wszystkie dokumenty gdzie monter wype≈Çni≈Ç
        docs = db.collection(collection_name).where(filter=firestore.FieldFilter('wypelnil_monter', '==', True)).get()
        
        forms_list = []
        for doc in docs:
            data = doc.to_dict()
            # Filtruj tylko te w etapie pomiar√≥w
            if data.get('etap_formularza') == 'pomiary':
                data['id'] = doc.id
                forms_list.append(data)
        
        # Sortuj wed≈Çug daty (najnowsze pierwsze)
        forms_list.sort(key=lambda x: x.get('data_utworzenia', datetime.min), reverse=True)
        return forms_list
        
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas pobierania formularzy do uzupe≈Çnienia: {e}")
        return []

def get_document_by_id(db, collection_name, doc_id):
    """
    Pobiera pojedynczy dokument z bazy danych po ID
    """
    try:
        doc_ref = db.collection(collection_name).document(doc_id)
        doc = doc_ref.get()
        
        if doc.exists:
            data = doc.to_dict()
            data['id'] = doc.id
            return data
        else:
            return None
            
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas pobierania dokumentu: {e}")
        return None

def update_document(db, collection_name, doc_id, updated_data):
    """
    Aktualizuje dokument w bazie danych
    """
    try:
        doc_ref = db.collection(collection_name).document(doc_id)
        doc_ref.update(updated_data)
        return True
        
    except Exception as e:
        st.error(f"B≈ÇƒÖd podczas aktualizacji dokumentu: {e}")
        return False

# =====================
# Kwarantanna (Szkice)
# =====================

def save_draft_data(db, collection_target, dane_formularza, monter_id):
    """
    Zapisuje szkic (kwarantanna) pomiar√≥w bez finalizacji do g≈Ç√≥wnej kolekcji.
    collection_target: 'drzwi', 'drzwi_wejsciowe' lub 'podlogi'
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return None

    try:
        now = datetime.now()
        dane = dane_formularza.copy()
        dane.update({
            "collection_target": collection_target,
            "status": "draft",
            "created_at": now,
            "updated_at": now,
            "monter_id": monter_id,
        })
        doc_ref = db.collection('wymiary_draft').add(dane)
        draft_id = doc_ref[1].id
        print(f"‚úÖ Zapisano szkic {collection_target} z ID: {draft_id}")
        return draft_id
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas zapisywania szkicu: {e}")
        return None

def get_drafts_for_monter(db, monter_id=None):
    """
    Pobiera szkice (kwarantanna). Je≈õli podano monter_id ‚Äì filtruje po monterze.
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return []

    try:
        ref = db.collection('wymiary_draft')
        if monter_id:
            query = ref.where(filter=firestore.FieldFilter('monter_id', '==', monter_id))
        else:
            query = ref
        docs = query.order_by('updated_at', direction=firestore.Query.DESCENDING).get()
        results = []
        for doc in docs:
            data = doc.to_dict()
            data['id'] = doc.id
            results.append(data)
        return results
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas pobierania szkic√≥w: {e}")
        return []

def update_draft_data(db, draft_id, updates):
    """Aktualizuje szkic"""
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return False
    try:
        updates = updates.copy()
        updates['updated_at'] = datetime.now()
        db.collection('wymiary_draft').document(draft_id).update(updates)
        return True
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas aktualizacji szkicu: {e}")
        return False

def delete_draft(db, draft_id):
    """Usuwa szkic"""
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return False
    try:
        db.collection('wymiary_draft').document(draft_id).delete()
        return True
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas usuwania szkicu: {e}")
        return False

def finalize_draft(db, draft_id):
    """
    Finalizuje szkic: przenosi dane do docelowej kolekcji ('drzwi', 'drzwi_wejsciowe' lub 'podlogi')
    i usuwa szkic. Zwraca (doc_id, kod_dostepu) lub (None, None) w razie b≈Çƒôdu.
    """
    if db is None:
        st.error("‚ùå Baza danych nie jest zainicjalizowana")
        return None, None
    try:
        snap = db.collection('wymiary_draft').document(draft_id).get()
        if not snap.exists:
            st.error("‚ùå Szkic nie istnieje")
            return None, None

        data = snap.to_dict()
        collection_target = data.get('collection_target')
        monter_id = data.get('monter_id', '')
        if collection_target not in ['drzwi', 'drzwi_wejsciowe', 'podlogi']:
            st.error("‚ùå Nieprawid≈Çowy typ szkicu")
            return None, None

        # Usu≈Ñ meta szkicu
        payload = data.copy()
        for meta_key in ['collection_target', 'status', 'created_at', 'updated_at', 'id']:
            payload.pop(meta_key, None)

        # Zapisz jako pomiary (monter)
        doc_id, kod = save_pomiary_data(db, collection_target, payload, monter_id)
        if doc_id:
            # Usu≈Ñ szkic
            db.collection('wymiary_draft').document(draft_id).delete()
            return doc_id, kod
        else:
            return None, None
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas finalizacji szkicu: {e}")
        return None, None

def generate_share_link(doc_id, kod_dostepu, collection_name):
    """
    Generuje link do udostƒôpnienia formularza
    """
    # W rzeczywistej aplikacji u≈ºy≈Çby≈õ prawdziwego URL
    return f"https://twoja-aplikacja.com/uzupelnij/{collection_name}/{doc_id}?kod={kod_dostepu}"

# ===================
# Obs≈Çuga zdjƒôƒá
# ===================

def upload_image_to_firebase(uploaded_file, folder_name, doc_id):
    """
    Przesy≈Ça zdjƒôcie do Firebase Storage
    Zwraca URL zdjƒôcia lub None w przypadku b≈Çƒôdu
    """
    try:
        if uploaded_file is None:
            return None
            
        # Sprawd≈∫ format pliku
        if not uploaded_file.type.startswith('image/'):
            st.error("‚ùå Mo≈ºna przesy≈Çaƒá tylko pliki obraz√≥w!")
            return None
            
        # Sprawd≈∫ rozmiar (maksymalnie 5MB)
        if uploaded_file.size > 5 * 1024 * 1024:
            st.error("‚ùå Plik jest za du≈ºy! Maksymalny rozmiar to 5MB")
            return None
            
        # Utw√≥rz unikalnƒÖ nazwƒô pliku
        file_extension = uploaded_file.name.split('.')[-1]
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = f"{folder_name}/{doc_id}/{timestamp}_{uploaded_file.name}"
        
        # Konwertuj i zmniejsz obraz je≈õli potrzeba
        image = Image.open(uploaded_file)
        
        # Zmniejsz obraz je≈õli jest za du≈ºy (maksymalnie 1920x1080)
        max_width = 1920
        max_height = 1080
        if image.width > max_width or image.height > max_height:
            image.thumbnail((max_width, max_height), Image.Resampling.LANCZOS)
        
        # Konwertuj do JPEG dla zmniejszenia rozmiaru
        if image.mode in ("RGBA", "P"):
            image = image.convert("RGB")
            
        # Zapisz do bufora
        buffer = io.BytesIO()
        image.save(buffer, format='JPEG', quality=85, optimize=True)
        buffer.seek(0)
        
        # Przesy≈Çanie do Firebase Storage wymaga konfiguracji bucket
        # Na razie zapisujemy jako base64 w bazie danych
        img_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return img_base64
        
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas przesy≈Çania zdjƒôcia: {e}")
        return None

def save_images_to_database(db, collection_name, doc_id, images_data):
    """
    Zapisuje dane zdjƒôƒá do dokumentu w bazie danych
    """
    try:
        db.collection(collection_name).document(doc_id).update({
            'zdjecia': images_data,
            'data_aktualizacji_zdjec': datetime.now()
        })
        return True
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas zapisywania zdjƒôƒá: {e}")
        return False

def display_images(images_data, max_width=300):
    """
    Wy≈õwietla zdjƒôcia z danych base64
    """
    if not images_data:
        st.info("üì∑ Brak zdjƒôƒá dla tego pomiaru")
        return
        
    st.subheader("üì∏ Zdjƒôcia z pomiar√≥w")
    
    # Wy≈õwietl zdjƒôcia w kolumnach
    cols = st.columns(3)
    for i, img_data in enumerate(images_data):
        with cols[i % 3]:
            try:
                # Dekoduj base64
                img_bytes = base64.b64decode(img_data['data'])
                
                # Wy≈õwietl zdjƒôcie
                st.image(img_bytes, caption=img_data.get('nazwa', f'Zdjƒôcie {i+1}'), width=max_width)
                
                # Poka≈º informacje o zdjƒôciu
                if 'data_dodania' in img_data:
                    st.caption(f"Dodano: {img_data['data_dodania'].strftime('%Y-%m-%d %H:%M')}")
                    
            except Exception as e:
                st.error(f"‚ùå B≈ÇƒÖd wy≈õwietlania zdjƒôcia {i+1}: {e}")

def create_image_uploader(key_prefix, max_files=5):
    """
    Tworzy interfejs do przesy≈Çania zdjƒôƒá
    Zwraca listƒô przes≈Çanych plik√≥w
    """
    st.subheader("üì∑ Dodaj zdjƒôcia z pomiar√≥w")
    st.write("Mo≈ºesz dodaƒá maksymalnie 5 zdjƒôƒá (formaty: JPG, PNG, maksymalnie 5MB ka≈ºde)")
    
    uploaded_files = st.file_uploader(
        "Wybierz zdjƒôcia:",
        type=['jpg', 'jpeg', 'png'],
        accept_multiple_files=True,
        key=f"{key_prefix}_image_uploader"
    )
    
    if uploaded_files:
        if len(uploaded_files) > max_files:
            st.warning(f"‚ö†Ô∏è Mo≈ºesz przes≈Çaƒá maksymalnie {max_files} zdjƒôƒá. Wybrano pierwsze {max_files}.")
            uploaded_files = uploaded_files[:max_files]
            
        # Poka≈º podglƒÖd zdjƒôƒá
        st.write("**PodglƒÖd zdjƒôƒá:**")
        cols = st.columns(min(len(uploaded_files), 3))
        
        for i, uploaded_file in enumerate(uploaded_files):
            with cols[i % 3]:
                try:
                    image = Image.open(uploaded_file)
                    st.image(image, caption=uploaded_file.name, width=200)
                    st.write(f"Rozmiar: {uploaded_file.size/1024:.1f} KB")
                except Exception as e:
                    st.error(f"‚ùå B≈ÇƒÖd podglƒÖdu: {e}")
                    
    return uploaded_files

def process_uploaded_images(uploaded_files, folder_name, doc_id):
    """
    Przetwarza przes≈Çane zdjƒôcia i zwraca dane do zapisania w bazie
    """
    if not uploaded_files:
        return []
        
    images_data = []
    
    for uploaded_file in uploaded_files:
        with st.spinner(f"Przetwarzanie {uploaded_file.name}..."):
            img_base64 = upload_image_to_firebase(uploaded_file, folder_name, doc_id)
            
            if img_base64:
                images_data.append({
                    'nazwa': uploaded_file.name,
                    'data': img_base64,
                    'rozmiar': uploaded_file.size,
                    'typ': uploaded_file.type,
                    'data_dodania': datetime.now()
                })
                
    return images_data

def display_images_with_edit(images_data, draft_id, max_width=300):
    """
    Wy≈õwietla zdjƒôcia z mo≈ºliwo≈õciƒÖ usuwania (dla przechowalni)
    """
    if not images_data:
        st.info("üì∑ Brak zdjƒôƒá dla tego szkicu")
        return images_data
        
    st.subheader("üì∏ Zdjƒôcia w szkicu")
    
    # Sprawd≈∫ czy jakie≈õ zdjƒôcie zosta≈Ço zaznaczone do usuniƒôcia
    images_to_delete = []
    
    # Wy≈õwietl zdjƒôcia w kolumnach
    cols_per_row = 3
    for i in range(0, len(images_data), cols_per_row):
        cols = st.columns(cols_per_row)
        
        for j in range(cols_per_row):
            idx = i + j
            if idx < len(images_data):
                img_data = images_data[idx]
                with cols[j]:
                    try:
                        # Dekoduj base64
                        img_bytes = base64.b64decode(img_data['data'])
                        
                        # Wy≈õwietl zdjƒôcie
                        st.image(img_bytes, caption=img_data.get('nazwa', f'Zdjƒôcie {idx+1}'), width=max_width)
                        
                        # Poka≈º informacje o zdjƒôciu
                        if 'data_dodania' in img_data:
                            try:
                                if hasattr(img_data['data_dodania'], 'strftime'):
                                    date_str = img_data['data_dodania'].strftime('%Y-%m-%d %H:%M')
                                else:
                                    date_str = str(img_data['data_dodania'])
                                st.caption(f"Dodano: {date_str}")
                            except:
                                st.caption("Dodano: nieznana data")
                        
                        # Przycisk usuwania
                        if st.button(f"üóëÔ∏è Usu≈Ñ", key=f"delete_img_{draft_id}_{idx}", help=f"Usu≈Ñ zdjƒôcie: {img_data.get('nazwa', f'Zdjƒôcie {idx+1}')}"):
                            images_to_delete.append(idx)
                            
                    except Exception as e:
                        st.error(f"‚ùå B≈ÇƒÖd wy≈õwietlania zdjƒôcia {idx+1}: {e}")
    
    # Je≈õli jakie≈õ zdjƒôcie zosta≈Ço zaznaczone do usuniƒôcia
    if images_to_delete:
        # Utw√≥rz nowƒÖ listƒô bez usuniƒôtych zdjƒôƒá
        images_to_keep = [img for i, img in enumerate(images_data) if i not in images_to_delete]
        return images_to_keep
    
    # Je≈õli nic nie zosta≈Ço usuniƒôte, zwr√≥ƒá oryginalne dane
    return images_data

def add_images_to_draft(db, draft_id, new_images_data):
    """
    Dodaje nowe zdjƒôcia do istniejƒÖcego szkicu
    """
    try:
        # Pobierz obecne dane szkicu
        draft_doc = db.collection('wymiary_draft').document(draft_id).get()
        if not draft_doc.exists:
            st.error("‚ùå Szkic nie istnieje")
            return False
            
        draft_data = draft_doc.to_dict()
        existing_images = draft_data.get('zdjecia', [])
        
        # Dodaj nowe zdjƒôcia do istniejƒÖcych
        all_images = existing_images + new_images_data
        
        # Aktualizuj szkic
        db.collection('wymiary_draft').document(draft_id).update({
            'zdjecia': all_images,
            'data_aktualizacji_zdjec': datetime.now(),
            'updated_at': datetime.now()
        })
        return True
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas dodawania zdjƒôƒá: {e}")
        return False

def update_draft_images(db, draft_id, images_data):
    """
    Aktualizuje zdjƒôcia w szkicu (u≈ºywane przy usuwaniu)
    """
    try:
        db.collection('wymiary_draft').document(draft_id).update({
            'zdjecia': images_data,
            'data_aktualizacji_zdjec': datetime.now(),
            'updated_at': datetime.now()
        })
        return True
    except Exception as e:
        st.error(f"‚ùå B≈ÇƒÖd podczas aktualizacji zdjƒôƒá: {e}")
        return False

# Funkcja inicjalizacyjna do wywo≈Çania przy starcie aplikacji
@st.cache_resource
def setup_database():
    """
    Inicjalizuje bazƒô danych i tworzy niezbƒôdne kolekcje
    """
    db = initialize_firebase()
    create_tables_if_not_exist(db)
    return db

